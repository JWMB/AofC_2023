# AofC_2023

Learning F# by doing [AdventOfCode 2023](https://adventofcode.com/2023)

Previous:
* [2021](https://github.com/JWMB/AofC_2021)
* [2022](https://github.com/JWMB/AofC_2022)


##Autogenerated##
## [Day 1 : Trebuchet?!](https://adventofcode.com/2023/day/1)
[Source](/AofC_2023/Days/D01.fs) | [Input](/AofC_2023/Days/D01.txt)  
### part1
```FSharp
let part1 input =
    let parseRow input =
        let digits = Regex.Replace(input, @"\D", "") |> Seq.toArray
        firstLast digits

    let rowValues = Parsing.parseRows input parseRow
    let result = Seq.sum rowValues
    result
```

Result (in `10`ms): `55607`
### part2
```FSharp
let part2 input =
    let digitWords = "zero one two three four five six seven eight nine".Split ' '
    let digitWordPattern = digitWords |> String.concat "|"
    let pattern = $@"({digitWordPattern}|\d)"

    let makeDigit str =
        match digitWords |> Array.tryFindIndex (fun f -> f = str) with
            | Some s -> s
            | _ -> int str

    let parseRow input =
        let first = Regex.Match(input, pattern)
        let last = Regex.Match(input, pattern, RegexOptions.RightToLeft)
        let matches = [| first; last |]
        let digits = matches |> Array.map (fun f -> makeDigit(f.Value))
        firstLast digits

    let rowValues = Parsing.parseRows input parseRow
    let result = Seq.sum rowValues
    result
```

Result (in `6`ms): `55291`
## [Day 2 : Cube Conundrum](https://adventofcode.com/2023/day/2)
[Source](/AofC_2023/Days/D02.fs) | [Input](/AofC_2023/Days/D02.txt)  
### part1
```FSharp
let part1 input =
    let (=>) x y = x,y
    let makeMap x = new Map<_,_>(x)
    let maxByColor =
        [
            Color.red => 12
            Color.green => 13
            Color.blue => 14
        ] |> makeMap

    let getExceedsMax colorCounts = 
        colorCounts
        |> Map.toArray
        |> Array.filter (fun (color, count) -> count > maxByColor[color])

    let anyTurnExceedsMax colorCounts = 
        getExceedsMax colorCounts 
        |> Array.length > 0

    let rows = Parsing.parseRows input parseRow

    let hasNoMoreThanMax row =
        row.Turns
        |> Array.filter anyTurnExceedsMax
        |> Array.length = 0

    let okIds = rows |> Array.filter hasNoMoreThanMax |> Array.map (fun f -> f.Id)
    let result = okIds |> Array.sum
    result
```

Result (in `12`ms): `2476`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow

    let maxOf map1 map2 = 
        merge map1 map2 (fun _ (v1: int, v2: int) -> Math.Max(v1, v2))
        
    let minCountsOfRow row =
        row.Turns
        |> Array.reduce (fun p c -> maxOf p c)

    let rowValue row =
        minCountsOfRow row
        |> Map.toArray
        |> Array.map (fun (_, cnt) -> cnt)
        |> Array.reduce (fun p c -> p * c)

    let rowValues = rows |> Array.map (fun r -> rowValue r)
    let result = rowValues |> Array.sum
    result
```

Result (in `6`ms): `54911`
## [Day 3 : Gear Ratios](https://adventofcode.com/2023/day/3)
[Source](/AofC_2023/Days/D03.fs) | [Input](/AofC_2023/Days/D03.txt)  
### part1
```FSharp
let part1 input =
    let map = constructMap input

    let symbolPositions = map.Symbols |> Array.map (fun f -> f.Coordinate)

    let maxDistance = 1
    let hasSymbolNeaby (coord: Vector2D) = 
        symbolPositions |> Array.exists (fun (xy: Vector2D) -> (coord.sub xy).maxAbs <= maxDistance)

    let hasSymbolNearby part =
        part.Coordinates |> Array.exists hasSymbolNeaby

    let partsWithSymbolNearby = map.Parts |> Array.filter (fun part -> hasSymbolNearby part)

    let result = partsWithSymbolNearby |> Array.sumBy (fun f -> f.Value)
    result
```

Result (in `63`ms): `557705`
### part2
```FSharp
let part2 input =
    let map = constructMap input

    let parts = map.Parts

    let gearSymbolCoordinates =
        map.Symbols
        |> Array.filter (fun f -> f.Value = '*')
        |> Array.map (fun f -> f.Coordinate)

    let maxDistance = 1

    let partsNearby coord =
        parts
        |> Array.filter (fun p ->
                        p.Coordinates
                        |> Array.exists (fun pos -> (pos.sub coord).maxAbs <= maxDistance)
                        )
        
    let gearsWithParts =
        gearSymbolCoordinates 
        |> Array.map (fun f -> {| Loc = f; Parts = partsNearby f; |})
        |> Array.filter (fun f -> f.Parts.Length = 2)

    let products =
        gearsWithParts
        |> Array.map (fun f -> f.Parts
                                |> Array.map (fun p -> p.Value)
                                |> Array.reduce (fun p c -> p * c)
                      )

    let result = products |> Array.sum
    result
```

Result (in `79`ms): `84266818`
## [Day 4 : Scratchcards](https://adventofcode.com/2023/day/4)
[Source](/AofC_2023/Days/D04.fs) | [Input](/AofC_2023/Days/D04.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow

    let cardCorrectValues row =
        Set.intersect (Set.ofArray row.Winning) (Set.ofArray row.Mine) |> Set.toArray

    let calcPoints correctValues =
        let exponent = (correctValues |> Array.length) - 1
        if exponent = -1 then 0 else int (2.0 ** exponent)

    let rowPoints = rows |> Array.map (fun f -> cardCorrectValues f |> calcPoints)
    let result = rowPoints |> Array.sum
    result
```

Result (in `8`ms): `25183`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow
    let cardCounts = rows |> Array.map (fun f -> 1) //(fun f -> (f.Id, 1)) |> Map.ofArray 

    let cardNumCorrectValues row =
        Set.intersect (Set.ofArray row.Winning) (Set.ofArray row.Mine) |> Set.count


    rows |> Array.iteri (fun rowIndex row ->
                    let numCorrect = cardNumCorrectValues row
                    let copiesOfThisCard = cardCounts.[rowIndex]
                    [| 1..numCorrect|] |> Array.iter (fun i -> cardCounts.[rowIndex + i] <- cardCounts.[rowIndex + i] + copiesOfThisCard)
                )

    let result = cardCounts |> Array.sum
    result
```

Result (in `8`ms): `5667240`
## [Day 5 : If You Give A Seed A Fertilizer](https://adventofcode.com/2023/day/5)
[Source](/AofC_2023/Days/D05.fs) | [Input](/AofC_2023/Days/D05.txt)  
### part1
```FSharp
let part1 (input: string) =
    let sections = parseInput input
    let initialState = Regex.Matches(sections[0].Content |> String.concat " ", @"\d+") |> Seq.toArray |> Array.map (fun f -> int64 f.Value)

    let parseRange (str: string) =
        let matches = Regex.Matches(str, @"\d+") |> Seq.toArray |> Array.map (fun f -> int64 f.Value)
        { Src = matches[1]; Dst = matches[0]; Length = matches[2] }

    let maps = sections |> Array.tail |> Array.map (fun f -> { Header = f.Header; Transforms = f.Content |> Array.map parseRange })

    let applyMaps value (maps: Map array) =
        applyManyPartials value (maps |> Array.map (fun m -> m.apply)) None |> Seq.toArray

    let final = initialState |> Array.map (fun value -> applyMaps value maps)
    let result = final |> Array.map (fun f -> f |> Array.last) |> Array.min
    result
    
type Range = { Start: int64; Length: int64; }
```

Result (in `10`ms): `240320250`
### part2
```FSharp
let part2 input =
    let sections = parseInput input
    let initialState =
        Regex.Matches(sections[0].Content
        |> String.concat " ", @"\d+")
        |> Seq.toArray |> Array.map (fun f -> int64 f.Value)
        |> Array.chunkBySize 2 
        |> Array.map (fun arr -> { Start = arr[0]; Length = arr[1] })

    let parseRange (str: string) =
        let matches = Regex.Matches(str, @"\d+") |> Seq.toArray |> Array.map (fun f -> int64 f.Value)
        { Src = matches[1]; Dst = matches[0]; Length = matches[2] }

    let maps = sections |> Array.tail |> Array.map (fun f -> { Header = f.Header; Transforms = f.Content |> Array.map parseRange })

    let ooo = maps[0].applyRange initialState[0].Length initialState[0].Length

    0

//    let parseRange (str: string) =
//        let matches = Regex.Matches(str, @"\d+") |> Seq.toArray |> Array.map (fun f -> int64 f.Value)
//        { Src = matches[1]; Dst = matches[0]; Length = matches[2] }

//    let maps = sections |> Array.tail |> Array.map (fun f -> { Header = f.Header; Transforms = f.Content |> Array.map parseRange })

//    let applyMaps value (maps: Map array) =
//        applyManyPartials value (maps |> Array.map (fun m -> m.apply)) None |> Seq.toArray

//    let final = initialState |> Array.map (fun value -> applyMaps value maps)
//    let result = final |> Array.map (fun f -> f |> Array.last) |> Array.min
//    result
```

Result (in `2`ms): `0`
## [Day 6 : Wait For It](https://adventofcode.com/2023/day/6)
[Source](/AofC_2023/Days/D06.fs) | [Input](/AofC_2023/Days/D06.txt)  
### part1
```FSharp
let part1 input =
    let parseRow (row: string) =
        let keyValues = row.Split ':'
        let values = Regex.Matches(keyValues[1], @"\d+") |> Seq.toArray |> Array.map(fun f -> double f.Value)
        (keyValues[0], values)

    let rows = Parsing.parseRows input parseRow |> Map.ofArray
    let races = rows["Time"] |> Array.mapi (fun i v -> { Time = v; Distance = rows["Distance"][i]})

    let partial = races |> Array.map (fun race -> numWaysToBeatRecord race.Time race.Distance)
    let result = partial |> Array.reduce (fun p c -> p * c)
    result
```

Result (in `11`ms): `2344708`
### part2
```FSharp
let part2 input =
    let parseRow (row: string) =
        let keyValues = row.Split ':'
        let values = double (keyValues[1].Replace(" ", ""))
        (keyValues[0], values)

    let rows = Parsing.parseRows input parseRow |> Map.ofArray
    let race = { Time = rows["Time"]; Distance = rows["Distance"]}
    let result = numWaysToBeatRecord race.Time race.Distance

    result
```

Result (in `1`ms): `30125202`
## [Day 7 : Camel Cards](https://adventofcode.com/2023/day/7)
[Source](/AofC_2023/Days/D07.fs) | [Input](/AofC_2023/Days/D07.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow

    let ranked =
        rows |> Array.sortWith (fun a b -> handComparer a.Cards b.Cards)
        |> Array.rev
        |> Array.mapi (fun i v -> {| Rank = i + 1; Hand = v |})

    let winnings = ranked |> Array.map (fun v -> v.Rank * v.Hand.Bet)
    let result = winnings |> Array.sum
    result
```

Result (in `42`ms): `246163188`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input (parseRowWithModifier (fun f -> if f = 11 then 1 else f))

    let optimizeHand hand =
        let numJokers = hand |> Array.filter (fun f -> f = 1) |> Array.length
        let replaceJokersWith value = hand |> Array.map (fun f -> if f = 1 then value else f)
        let whichHasMostOccurrencies = lazy (
            let sortedByMost = hand
                            |> Array.filter (fun f -> f > 1)
                            |> Array.groupBy (fun f -> f)
                            |> Array.map (fun (k, v) -> (k, v.Length))
                            |> Array.sortByDescending (fun (k, v) -> v)
            let count = snd sortedByMost[0]
            let onlyWithMost = sortedByMost |> Array.filter (fun (k, v) -> v = count) |> Array.map(fun f -> fst f)
            onlyWithMost |> Array.max
            )

        match numJokers with
        | 5 -> hand
        | 4 | 3 -> replaceJokersWith (hand |> Array.max)
        | 2 | 1 -> replaceJokersWith whichHasMostOccurrencies.Value
        | _ -> hand

    let ranked =
        rows |> Array.sortWith (fun a b -> handComparerWithTypes a.Cards b.Cards (a.Cards |> optimizeHand |> getHandType) (b.Cards |> optimizeHand |> getHandType))
        |> Array.rev
        |> Array.mapi (fun i v -> {| Rank = i + 1; Hand = v |})

    let winnings = ranked |> Array.map (fun v -> v.Rank * v.Hand.Bet)
    let result = winnings |> Array.sum
    result
```

Result (in `65`ms): `245794069`
## [Day 8 : Haunted Wasteland](https://adventofcode.com/2023/day/8)
[Source](/AofC_2023/Days/D08.fs) | [Input](/AofC_2023/Days/D08.txt)  
### part1
```FSharp
let part1 input =
    let input = Parsing.cleanWithTrimEmptyLines input
    let chunks = Regex.Split(input, "\n\n");
    let turns = chunks[0]
    let nodes = constructNodes chunks[1]

    let rec loop currentNode stepIndex =
        let turn = turns[stepIndex % turns.Length]
        let turnArrIndex = if turn = 'L' then 0 else 1
        let nextNodeId = nodes[currentNode][turnArrIndex]
        if nextNodeId = "ZZZ" then stepIndex
        else loop nextNodeId (stepIndex + 1)
        
    let numSteps = 1 + loop "AAA" 0
    numSteps
```

Result (in `9`ms): `22411`
### part2
```FSharp
let part2 input =
    let input = Parsing.cleanWithTrimEmptyLines input
    let chunks = Regex.Split(input, "\n\n");
    let turns = chunks[0] |> Seq.toArray |> Array.map (fun turn -> if turn = 'L' then 0 else 1)
    let nodes = constructNodes chunks[1]

    let endNodes = nodes |> Map.toArray |> Array.map (fun f -> fst f) |> Array.filter (fun f -> f.EndsWith "Z")

    let rec getIndicesWhenAtEnd currentNode stepIndex (visitHistory: System.Collections.Generic.List<System.Tuple<string, int>>) =
        seq {
            let indexMod = stepIndex % turns.Length
            let turn = turns[indexMod]
            let stateId = (currentNode, indexMod)
            if visitHistory.Contains stateId then
                yield stepIndex
            else
                visitHistory.Add(stateId)

                let nextNodeId = nodes[currentNode][turn]
                if endNodes |> Array.contains nextNodeId then // if nextNodeId.EndsWith("Z") then
                    yield stepIndex
                yield! getIndicesWhenAtEnd nextNodeId (stepIndex + 1) visitHistory
        }
    
    let initialState = nodes |> Map.toArray |> Array.map (fun (k, _) -> k) |> Array.filter (fun k -> k.EndsWith("A"))
    
    let leastCommonDenominator (values: int array) =
        let factorialize value =
            let max = int (Math.Sqrt (double value))
            let rec loop v (den: int) = seq {
                if den > max then
                    yield v
                else if v > 1 then
                    let isDivisible = v % den = 0
                    if isDivisible then
                        yield den

                    let nextDen = den + if isDivisible then 0 else (if den > 2 then 2 else 1)
                    let nextV = if isDivisible then v / den else v
                    yield! loop nextV nextDen

            }
            loop value 2 |> Seq.toArray
        let valueFactors = values |> Array.map factorialize

        let allDistinctFactors = valueFactors |> Array.reduce Array.append |> Array.distinct
        let countsByFactor =
            allDistinctFactors
            |> Array.map (fun f -> {|
                                    Factor = f; 
                                    Counts = valueFactors |> Array.map (fun arr -> arr |> Array.filter (fun v -> v = f) |> Array.length)
                                    |})

        let common =
            countsByFactor
            |> Array.map (fun f -> 
                    let min = f.Counts |> Array.min
                    if min = 0 then 1 else f.Factor * min
                    )
            |> Array.reduce (fun a b -> a * b)
        common

    //let aaa = leastCommonDenominator [| 22420; 18115; 13204; 24255; 14434; 16273|]
    //let aaa = leastCommonDenominator [| 12; 42; 256 *3  |] 


    let fullLoops =
        initialState
        |> Array.map (fun f -> getIndicesWhenAtEnd f 0 (new System.Collections.Generic.List<System.Tuple<string, int>>()))
        |> Array.map (fun f -> f |> Seq.toArray)
        |> Array.map (fun f -> {| Length = f |> Array.last; Goals = f[0..f.Length-2] |})
    
    // Example: 
    // period 6, goal 3 = 3 + 6a
    //  3 9 15 21 27 33 39
    // period 4, goal 1 = 1 + 4b
    //  1 5 9 13 17 21 25 29 33
    // period 9, goal 5 = 9 + 5c
    //  5 14 23 32 41
    // Find first when all 3 are the same

    let longestPeriod = fullLoops |> Array.maxBy(fun f -> f.Length)
    // Length: 5 / 1, 3
    let rec findCommon iteration =
        let adjustedIndices = fullLoops |> Array.map (fun f -> f.Goals |> Array.map (fun x -> x + iteration * f.Length))
        if true then findCommon iteration + 1
        else 0

    //findCommon 0

    0
```

Result (in `16563`ms): `0`
## [Day 9 : Mirage Maintenance](https://adventofcode.com/2023/day/9)
[Source](/AofC_2023/Days/D09.fs) | [Input](/AofC_2023/Days/D09.txt)  
### part1
```FSharp
let part1 input =
    let rows = Parsing.parseRows input parseRow
    let lastValues = rows |> Array.map (fun f -> getValueFromEachStep f Array.last)
    let newLastValues = lastValues |> Array.map (fun a -> a |> Array.sum)

    let result = newLastValues |> Array.sum
    result
```

Result (in `10`ms): `1584748274`
### part2
```FSharp
let part2 input =
    let rows = Parsing.parseRows input parseRow
    let firstValues = rows |> Array.map (fun f -> getValueFromEachStep f (fun a -> a[0]))
    let newFirstValues = firstValues  |> Array.map (fun arr -> arr |> Array.rev |> Array.reduce (fun a b -> b - a))

    let result = newFirstValues |> Array.sum
    result
```

Result (in `7`ms): `1026`
